##### 全局锁

```mysql
Flush tables with read lock (FTWRL)
对整个数据库实例加锁，让整个库处于只读状态，所有增删改操作都会被阻塞
```

##### 表级锁

```mysql
1.表锁：
  lock tables … read/write
  unlock tables  主动释放锁，也可以在客户端断开的时候自动释放

2.MDL锁：meta data lock
  MDL读锁：对表做增删改查操作
  MDL写锁：对表做结构变更操作
  
  *读锁之间不互斥，因此可以有多个线程同时对一张表增删改查。
  *读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性
```

##### 行锁

```mysql
* 存储引擎层由各个引擎自己实现的(MyISAM就不支持行锁, InnoDB支持)

* 行锁是针对数据表中行记录的锁。如事务 A 更新某行，同时事务 B 也要更新同一行，则必须等事务 A 的操作完成后才能进行更新。

  begin  
  update A；
  update B；
  commit；   ## 行锁是在commit后才释放的

* 行锁也有读写锁，读锁不冲突，读写、写写冲突
```

##### 死锁解决

```mysql
1. innodb_lock_wait_timeout：设置死锁等待超时时间，时间到后第一个被锁住的线程会被退出

2. innodb_deadlock_detect:on 发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。

3. 并发控制 & 优化容易死锁的行：比如某行容易发生死锁，可以考虑将该行拆分为多行，多行的总和等于原先的行  
```
