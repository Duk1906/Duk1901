##### ACID属性

* A：原子性：要么全部成功，要么全部回滚
* C：一致性：对集群，事务前后集群的数据是保持一致的；单实例理解一致性，似乎有点微妙
* I ：隔离性：事务间互不影响
* D：持久性：事务的改动不可逆



##### 隔离级别

* 可重复读：一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的；查询只承认在事务启动前就已经提交完成的数据

* 读提交：一个事务提交后，它做的变更才会被其他事务看到；查询只承认在语句启动前就已经提交完成的数据

* 读未提交/当前读: 一个事务还没提交时，它做的变更就能被别的事务看到；总是读取已经提交完成的最新版本

* 串行化：对于同一行记录，“写”加“写锁”，“读”加“读锁”。当出现读写锁冲突时，后访问的事务必须等前一个事务执行完成，才能继续执行。

* InnoDB 的默认事务隔离级别是可重复读

  

##### 多版本并发控制（MVCC）

- 同一条记录/行在系统中可以存在多个版本
- InnoDB 利用了“所有数据都有多个版本”的这个特性，实现了“秒级创建快照”的能力



##### 隔离实现

* 可重复读隔离级别：是通过视图实现的，整个事务存在期间都用这个视图。  事务id标注行 + undolog回滚至目标事务id对应的行内容

* 读提交隔离级别：  视图是在每个 SQL 语句开始执行的时候创建的。

* 读未提交隔离级别：直接返回记录上的最新值，没有视图概念

* 串行化隔离级别： 直接用加锁的方式来避免并行访问

 

```mysql
查看配置的隔离级别：
mysql> show variables like 'transaction_isolation';
+-----------------------+----------------+
| transaction_isolation | READ-COMMITTED |
+-----------------------+----------------+

事务操作
begin 或 start transaction
commit或 rollback
```



##### 幻读

* 指一个事务在前后两次查询同一个范围的时候，后一次查询看到了前一次查询没有看到的行
* 可重复读隔离级别下，查询是快照读，不会看到别的事务插入的数据。因此，幻读在“当前读”下才会出现
* 幻读仅专指 “新插入的行”

```mysql
select * from t where d=5 for update  # for update表示当前读，能读到当前所有已提交记录的最新值
```

产生幻读的原因：行锁只能锁住行，但是新插入记录这个动作，要更新的是记录之间的“间隙”

解决幻读问题：InnoDB 引入间隙锁 (Gap Lock)，防止区间内插入新的行 

PS：有空再研究下间隙锁
